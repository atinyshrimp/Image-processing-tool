<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PSI_Joyce</name>
    </assembly>
    <members>
        <member name="T:PSI_Joyce.Complex">
            <summary>
            Class used to manipulate complex numbers, to be used when creating the fractal
            </summary>
        </member>
        <member name="P:PSI_Joyce.Complex.Real">
            <summary>
            Real part of the current complex number
            </summary>
        </member>
        <member name="P:PSI_Joyce.Complex.Imaginary">
            <summary>
            Imaginary part of the current complex number
            </summary>
        </member>
        <member name="P:PSI_Joyce.Complex.Module">
            <summary>
            Module of the current complex number
            </summary>
        </member>
        <member name="P:PSI_Joyce.Complex.Sinh">
            <summary>
            Hyperbolic sine of the complex number
            </summary>
        </member>
        <member name="P:PSI_Joyce.Complex.Sin">
            <summary>
            Sine of the current complex number
            </summary>
        </member>
        <member name="M:PSI_Joyce.Complex.#ctor(System.Single,System.Single)">
            <summary>
            Create an instance of Complex using the provided parts
            </summary>
            <param name="real">Real part of the complex number</param>
            <param name="imaginary">Imaginary part of the complex number</param>
        </member>
        <member name="M:PSI_Joyce.Complex.Pow(System.Int32)">
            <summary>
            Applies an integer power to the complex number of the current instance
            </summary>
            <param name="power">Power to apply</param>
            <returns>A Complex object corresponding to the original Complex to the power-th power</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Multiply(PSI_Joyce.Complex,PSI_Joyce.Complex)">
            <summary>
            Multiply two Complex numbers together
            </summary>
            <param name="a">Multiplier</param>
            <param name="b">Multiplicand</param>
            <returns>Product of the two Complex objects</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Division(PSI_Joyce.Complex,PSI_Joyce.Complex)">
            <summary>
            Applies division to two Complex numbers
            </summary>
            <param name="a">Dividend</param>
            <param name="b">Divisor</param>
            <returns>Quotient of the two Complex objects</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Division(PSI_Joyce.Complex,System.Int32)">
            <summary>
            Divide a complex number by an integer
            </summary>
            <param name="a">Complex dividend</param>
            <param name="b">Integer divisor</param>
            <returns>Quotient of Complex a by the integer b</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Addition(PSI_Joyce.Complex,PSI_Joyce.Complex)">
            <summary>
            Adds two Complex numbers together
            </summary>
            <param name="a">First term of the addition</param>
            <param name="b">Second term of the addition</param>
            <returns>Sum of the two Complex objects</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Addition(PSI_Joyce.Complex,System.Int32)">
            <summary>
            Adds an integer to a complex number
            </summary>
            <param name="a">Complex term of the addition</param>
            <param name="b">Integer term of the addition</param>
            <returns>Sum of Complex a with the integer b</returns>
        </member>
        <member name="M:PSI_Joyce.Complex.op_Subtraction(PSI_Joyce.Complex,PSI_Joyce.Complex)">
            <summary>
            Subtract two Complex numbers from each other
            </summary>
            <param name="a">Minuend</param>
            <param name="b">Subtrahend</param>
            <returns>Complex corresponding to the difference of Complex a and Complex b</returns>
        </member>
        <member name="T:PSI_Joyce.Convolution">
            <summary>
            Classe répertoriant les matrices de convolution utilisées pour le traitement d'image fait dans la classe MyImage
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.Blur">
            <summary>
            
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.Sharpen">
            <summary>
            
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.EdgeDetect">
            <summary>
            
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.EdgeDetectBis">
            <summary>
            
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.Embossing">
            <summary>
            
            </summary>
        </member>
        <member name="P:PSI_Joyce.Convolution.Identity">
            <summary>
            
            </summary>
        </member>
        <member name="T:PSI_Joyce.HeaderInfo">
            <summary>
            Class containing all header information of a bitmap file
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.Size">
            <summary>
            Bitmap file size (including headers)
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.SizeOffset">
            <summary>
            The index where the bitmap of the image begins (54 in most cases)
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.Height">
            <summary>
            Height of the image, given in pixels
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.Width">
            <summary>
            Width of the image, given in pixels
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.Padding">
            <summary>
            Number of 0s to count to save the image properly in Bitmap file format
            </summary>
        </member>
        <member name="P:PSI_Joyce.HeaderInfo.Array">
            <summary>
            Byte array containing all header bytes of the bitmap file
            </summary>
        </member>
        <member name="M:PSI_Joyce.HeaderInfo.#ctor(System.String)">
            <summary>
            Creating the header of an image from its path
            </summary>
            <param name="file">Path leading to the .bmp file from which the header will be created</param>
        </member>
        <member name="M:PSI_Joyce.HeaderInfo.#ctor(PSI_Joyce.Pixel[0:,0:])">
            <summary>
            Creation of the header of an image from a Pixel matrix
            </summary>
            <param name="pxm">Pixel array representing an image</param>
            
        </member>
        <member name="T:PSI_Joyce.MyImage">
            <summary>
            Class recreating the principle of Microsoft's Bitmap class
            </summary>
        </member>
        <member name="P:PSI_Joyce.MyImage.Header">
            <summary>
            Class grouping all the header information (first 54 bytes) of the .bmp file
            </summary>
        </member>
        <member name="P:PSI_Joyce.MyImage.Image">
            <summary>
            Image transcribed into a Pixel matrix
            </summary>
        </member>
        <member name="M:PSI_Joyce.MyImage.#ctor(System.String)">
            <summary>
            Creates a MyImage object from a file
            </summary>
            <param name="file">bitmap file (.bmp) serving as the basis for creating the instance</param>
        </member>
        <member name="M:PSI_Joyce.MyImage.#ctor(PSI_Joyce.Pixel[0:,0:])">
            <summary>
            Creates an instance of MyImage from a Pixel array
            </summary>
            <param name="pxm">Pixel matrix corresponding to an image</param>
        </member>
        <member name="M:PSI_Joyce.MyImage.FromImageToFile(System.String)">
            <summary>
            Saves the image, following any changes made, to a folder on the computer
            </summary>
            <param name="file">Path under which to save the image</param>
        </member>
        <member name="M:PSI_Joyce.MyImage.EndianToInt(System.Byte[])">
            <summary>
            Convert the passed array of bytes into an integer
            </summary>
            <param name="tab">Byte array to convert</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.IntToEndian(System.Int32,System.Int32)">
            <summary>
            Convert an integer to an array of bytes
            </summary>
            <param name="val">Integer to convert</param>
            <param name="length">Length of the wanted array (either 2 or 4)</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.FillBinary(System.String,System.Int32)">
            <summary>
            Fills a string representing a binary number with 0s on the left
            </summary>
            <param name="bin">The binary number to fill</param>
            <param name="length">Total number of bits wanted</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Greyscale">
            <summary>
            Makes instance of MyImage grayscale
            </summary>
            <returns>a matrix of Pixels, each Pixel corresponding to a shade of gray</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.BlackAndWhite">
            <summary>
            Turns the current image in black and white
            </summary>
            <returns>Pixel Matrix where each Pixel is either black or white</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Negative">
            <summary>
            Reverses the colors of the current image
            </summary>
            <returns>Pixel Matrix where each pixel is the negative color of the original pixel</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Mirror">
            <summary>
            Flips the image diagonally
            </summary>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.MirrorX">
            <summary>
            Flip the image along the x-axis
            </summary>
            <returns>Pixel matrix symmetrical to that of the current instance relative to the x-axis</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.MirrorY">
            <summary>
            Flip the image along the y-axis
            </summary>
            <returns>Pixel matrix symmetrical to that of the current instance relative to the y-axis</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Scale(System.Single)">
            <summary>
            Enlarges or shrinks the current image according to the factor passed in parameter
            </summary>
            <param name="ratio">scale factor: float strictly greater than 0</param>
            <returns>Pixel matrix enlarged if ratio > 1 and reduced if ratio is between 0 and 1</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Rotate(System.Int32)">
            <summary>
            Rotates the pixel matrix of the current MyImage instance, clockwise (+) and counter-clockwise (-)
            </summary>
            <param name="angle">angle (in degrees) to use when rotating (negative for clockwise)</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Convolve(System.Single[0:,0:])">
            <summary>
            Applique une convolution sur l'image de l'instance courante
            </summary>
            <param name="filtre">Noyau à utiliser lors de la convolution</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Blur">
            <summary>
            Applique un effet flou sur l'image courante
            </summary>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.EdgeDetection">
            <summary>
            Applique l'effet "détection des bords" sur l'image courante
            </summary>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Sharpening">
            <summary>
            Applique l'effet "Sharpening" sur l'image courante
            </summary>
            <returns>Matrice de Pixel correspondant à une image plus nette que l'originale</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Embossing">
            <summary>
            Renforce les bords d'une image
            </summary>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Histogram">
            <summary>
            Génère un histogramme de toutes les couleurs de l'image
            </summary>
            <returns>Matrice de pixels représentant un histogramme RGB d'une image</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Histogram(System.String)">
            <summary>
            Génère un histogramme basé sur l'image de l'instance courante et la couleur soumise
            </summary>
            <param name="color">Couleur sur laquelle l'histogramme sera basé</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.EncodeImage(PSI_Joyce.Pixel[0:,0:])">
            <summary>
            Cache une image dans une autre
            </summary>
            <param name="mat">Image à masquer dans l'instance actuelle</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.DecodeImage">
            <summary>
            Récupère une image cachée dans une autre, s'il y en a une
            </summary>
            <returns>L'image cachée dans l'instance courante</returns>
        </member>
        <member name="M:PSI_Joyce.MyImage.Fractal(System.String)">
            <summary>
            Génère une fractale parmi une sélection
            </summary>
            <param name="type">type de la fractale voulue</param>
            <returns>Image (matrice de pixels) représentant une fractale</returns>
        </member>
        <member name="T:PSI_Joyce.Pixel">
            <summary>
            Classe gérant le fonctionnement des pixels
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.Red">
            <summary>
            Composante rouge du Pixel
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.Green">
            <summary>
            Composante verte du Pixel
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.Blue">
            <summary>
            Composante bleue du Pixel
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.Avrg">
            <summary>
            La moyenne des trois composantes
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.Item(System.Int32)">
            <summary>
            Indexation de la classe Pixel
            </summary>
            <param name="n">0 : Composante rouge; 1 : Verte; 2 : Bleue</param>
            <returns>Byte correspondant à la composante selectionnée</returns>
        </member>
        <member name="P:PSI_Joyce.Pixel.Black">
            <summary>
            Pixel représentant la couleur noire
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.White">
            <summary>
            Pixel représentant la couleur blanche
            </summary>
        </member>
        <member name="P:PSI_Joyce.Pixel.BlueColor">
            <summary>
            Pixel représentant la couleur bleue
            </summary>
        </member>
        <member name="M:PSI_Joyce.Pixel.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Construit un Pixel, triplet de bytes correspondant aux composantes rouge, verte et bleu d'une couleur
            </summary>
            <param name="red">Composante rouge du Pixel, comprise entre 0 et 255</param>
            <param name="green">Composante verte du Pixel, comprise entre 0 et 255</param>
            <param name="blue">Composante bleue du Pixel, comprise entre 0 et 255</param>
        </member>
        <member name="M:PSI_Joyce.Pixel.op_Equality(PSI_Joyce.Pixel,PSI_Joyce.Pixel)">
            <summary>
            Vérifie si deux instances de Pixel sont égales
            </summary>
            <param name="a">Premier pixel (comparateur)</param>
            <param name="b">Deuxième pixel (comparé)</param>
            <returns>True si les deux Pixels sont les mêmes, False sinon</returns>
        </member>
        <member name="M:PSI_Joyce.Pixel.op_Inequality(PSI_Joyce.Pixel,PSI_Joyce.Pixel)">
            <summary>
            Vérifie si deux instances de Pixel sont différentes
            </summary>
            <param name="a">Premier pixel (comparateur)</param>
            <param name="b">Deuxième pixel (comparé)</param>
            <returns>True si les deux Pixels sont différents, False sinon</returns>
        </member>
        <member name="M:PSI_Joyce.Pixel.ReadPixel(System.Collections.Generic.Queue{System.Byte})">
            <summary>
            
            </summary>
            <param name="queue">Queue contenant tous les bytes de l'image bitmap</param>
            <returns>Pixel correspondant aux trois premiers bytes dans la Queue passée en paramètres</returns>
        </member>
        <member name="M:PSI_Joyce.Pixel.XOR(PSI_Joyce.Pixel,PSI_Joyce.Pixel)">
            <summary>
            Applique l'opération logique "Ou exclusif"
            </summary>
            <param name="a">Première entrée</param>
            <param name="b">Deuxième entrée</param>
            <returns>Pixel noir si les deux entrées sont différentes, Pixel blanc sinon</returns>
        </member>
        <member name="M:PSI_Joyce.Pixel.Grayscale">
            <summary>
            Colore le Pixel courant en nuance de gris
            </summary>
            <returns>Pixel grisé</returns>
        </member>
        <member name="M:PSI_Joyce.Pixel.Negative">
            <summary>
            Applique l'effet "Négatif" à l'instance courante de Pixel
            </summary>
            <returns>Pixel correspondant à la couleur inverse du Pixel de base</returns>
        </member>
        <member name="T:PSI_Joyce.Program">
            <summary>
            
            </summary>
        </member>
        <member name="M:PSI_Joyce.Program.AfficheTableau(System.Byte[])">
            <summary>
            Affiche un tableau de bytes (méthode utilisée dans les tests)
            </summary>
            <param name="tab">tableau de bytes à afficher</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.Program.AfficheTableau(System.String[])">
            <summary>
            Affiche un tableau de string (méthode utilisée dans les tests)
            </summary>
            <param name="tab">tableau de chaînes de caractères à afficher</param>
            <returns></returns>
        </member>
        <member name="T:PSI_Joyce.QRCode">
            <summary>
            Classe gérant le fonctionnement d'un QRCode
            </summary>
        </member>
        <member name="P:PSI_Joyce.QRCode.Character">
            <summary>
            Ensemble des caractères pris en compte par le mode alphanumérique
            </summary>
        </member>
        <member name="P:PSI_Joyce.QRCode.Code">
            <summary>
            Image du QR Code final
            </summary>
        </member>
        <member name="P:PSI_Joyce.QRCode.BitChain">
            <summary>
            Ensemble des bits à encoder dans l'image finale à retourner
            </summary>
        </member>
        <member name="P:PSI_Joyce.QRCode.Mask">
            <summary>
            Matrice de Pixels correspondant au masque à appliquer au QRCode
            </summary>
        </member>
        <member name="M:PSI_Joyce.QRCode.#ctor(System.String)">
            <summary>
            Crée une instance de QR Code à partir d'une chaîne de caractères
            </summary>
            <param name="data">Mot à convertir en QR Code</param>
        </member>
        <member name="M:PSI_Joyce.QRCode.FindIndex(System.Char)">
            <summary>
            Cherche à quel index la lettre passée en paramètres se trouve dans le tableau de caractères disponibles dans le mode alphanumérique
            </summary>
            <param name="lettre">Caractère à chercher dans le tabelau</param>
            <returns>Un entier correspondant à la place occupée par la lettre</returns>
        </member>
        <member name="M:PSI_Joyce.QRCode.GetPairs">
            <summary>
            Sépare le mot à retranscrire en QRCode en paires
            </summary>
            <returns>Tableau de string où chaque index contient une chaîne de deux caractères (ou un seul pour le dernier index en fonction des cas)</returns>
        </member>
        <member name="M:PSI_Joyce.QRCode.Binary(System.String)">
            <summary>
            Donne le nombre binaire correspondant à la paire de caractères passée en paramètres
            </summary>
            <param name="pair">Deux caractères à "traduire" en base 2</param>
            <returns></returns>
        </member>
        <member name="M:PSI_Joyce.QRCode.PrintCode">
            <summary>
            Applique un Padding de un Pixel au QRCode
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
